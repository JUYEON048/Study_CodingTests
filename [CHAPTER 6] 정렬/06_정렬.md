## **[CHAPTER 6] 정렬**
<br/>

- **정렬(Sorting)** 이란 데이터를 특정한 기준에 따라 순서대로 나열하는 것을 말합니다.
- 일반적으로 문제 상황에 따라서 적절한 정렬 알고리즘이 공식처럼 사용됩니다.
<br/>
<br/>
<br/>

- **[선택 정렬]** <br/> 
    - 처리되지 않은 데이터 중에서 가장 자근 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복함.
<br/>
<br/>
<br/>

- **[삽입 정렬]**  <br/>
    - 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입. <br/>
    - 선택정렬에 비해 구현  난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작.
    - 첫 번째 데이터는 그 자체로 정렬이 되어 있다고 판단하고, 두  번째 데이터가 어떤 위치로 들어갈지 판단하는 것.
    - 데이터는 왼쪽/오른쪽으로 들어갈 수 있음.
    - 삽입 정렬은 선택 정렬과 마찬가지로 반복문이 두 번 중첩되어 사용.
    - 삽입 정렬은 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작.
<br/>
<br/>
<br/>

- **[퀵 정렬]** <br/>
    - 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법.
    - 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나.
    - 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘.
    - 가장 기본적인 퀵 정렬은 첫 번째 데이터를 기준 데이터(Pivot)로 설정. <br/>
<br/>

  1) 현재 피벗(Pivot)값이 K일 때, 왼쪽에서부터 K보다 큰 데이터를 선택하고, 오른쪽에서부터 K보다 작은 데이터를 선택한 후 두 데이터의 위치를 서로 변경.
     
  2) 1번 과정을 반복 진행하던 중, 작은 데이터와 큰 데이터의 위치가 엇갈리는 경우 '피벗'과 '작은 데이터'의 위치를 서로 변경.
     
  3) 2번 과정 이후 피벗값을 기준으로 오른쪽에 있는 데이터는 모두 K보다 크고, 왼쪽에 있는 데이터는 모두 K보다 작 음. 이렇게 피벗을 기준으로 데이터 묶음을 나누는 작업을 **분할(Divide)라고** 함.
   
  4) 이 후, 왼쪽에 있는 데이터에 대해서 마찬가지로 정렬 수행.
   
  5) 이 후, 오른쪽에 있는 데이터에 대해서 ... 정렬이 다 될때까지 반복 수행!

<br/>
<br/>
<br/>

- **[계수 정렬]** <br/>
    - 상대적으로 공간 복잡도가 높지만, 특정한 조건이 부합할 때만 사용할 수 있지만 매울 빠르게 동작하는 정렬 알고리즘.
    - 계수 정렬을 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때 사용 가능함. <br/>
<br/>

    1) 가장 작은 데이터부터 가장 큰 데이터ㅏ까지의 범위가 모두 담길 수 있도록 리스트 생성.
    2) 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가.
    3) 결과적으로 최종 리스트에는 각 데이터가 몇 번씩 등장했는지 그 횟수가 기록됨.
    4) 결과를 확인할 때는 리스트의 첫 번째 데이터부터 하나씩 그 값만큼 반복하여 인덱스를 출력.